# UBO Relay Chat

[Lien du cours](https://docs.google.com/presentation/d/1p-KtmWjFnfrZP-NrXgGACX2TSRNJXMdJ)

## Objectifs

Cr√©er une application de messagerie type IRC / WhatApp : [d√©mo](https://urc.vercel.app/)

TP r√©alisable en bin√¥mes ; mais dans ce cas, je veux un acc√®s au repos Git pour v√©rifier la contribution √©quitable de chacun.

Le but de ce TP est de fournir un cadre permettant l'exploration et l'exp√©rimentation.
A vous de vous plonger dans la documentation des diff√©rents outils utilis√©s (Redis, Node.js, Crypto, Push API) pour comprendre leur fonctionnement et les prendre en main.
La poursuite d'id√©es personnelles et l'ajout de fonctionnalit√©s additionnelles sont vivement encourag√©es.


## Intro

Pour r√©aliser ce TP, nous allons utiliser la plateforme [vercel](https://vercel.com/dashboard) qui propose diff√©rents supports de stockage de donn√©es : 

 - Une base de donn√©es relationnelle de type PostgreSQL pour stocker nos utilisateurs
 - Un cache de type Redis pour g√©rer les sessions utilisateurs (v√©rifier qu'ils se sont bien connect√©s)
 - Un stockage fichier de type bucket s3, afin d'h√©berger les images (et GIF) envoy√©s dans les conversations


## Setup

- Installer la derni√®re version de Node.js depuis le [site web](https://nodejs.org/en/download)
- ‚ö†Ô∏è Les distributions Ubuntu contiennent g√©n√©ralement une version obsol√®te dans leur repos, donc la commande `apt-get install` ne permet pas de r√©cup√©rer une version r√©cente.
- Forker le template du projet et le versionner sur Git.
- L'int√©ger √† [vercel](https://vercel.com/dashboard)
- Instancier sur vercel 2 [stores](https://vercel.com/dashboard/stores) : une base de donn√©es N√©on (PostgreSQL) et un cache Upstash KV (bas√© sur Redis)
- Depuis l'onglet `storage` de son projet, connecter les 2 stores afin qu'ils soient accessibles par l'application
- V√©rifier dans l'onglet `Settings/Environment Variables` que toutes les infos de connexion aux stores sont bien pr√©sentes
- Depuis la BDD "Neon", cliquer sur le bouton `Open in Neon`, puis sur l'onglet `SQL Editor`, afin d'avoir acc√®s √† une console SQL en ligne.
- Ex√©cuter les requ√™tes pr√©sentes dans le fichier [scripts/db.sql](scripts/db.sql))
- Installer le [CLI](https://vercel.com/docs/cli) et le lier au projet local via la commande `vercel link`
- R√©cup√©rer la configuration des DBs cr√©√©es en local : `vercel env pull .env.development.local`
- Charger les variables d'environnement : `export $(cat .env.development.local | xargs)`
- Installer les d√©pendances du projet : `npm install` ou `yarn install`

 
> [!CAUTION]
> Le projet **ne peut pas** √™tre lanc√© avec la commande `npm run start` ou `npm run dev` car celle-ci ne lancerait que l'application React et pas les fonctions Serveless utilis√©es pour se connecter √† la base de donn√©es et au cache.  
> üöÄ Pour lancer le projet, il faut utiliser la commande `vercel dev`

 
La requ√™te pr√©sente dans le fichier [scripts/db.sql](scripts/db.sql) permet d'initialiser un utilisateur `test / testubo`.
Si tout est bon, il devrait permettre de se connecter sur l'√©bauche de formulaire fourni.


### Structure du projet

Le template du projet est configur√© avec `Typescript`.
Bien que son utilisation soit tr√®s vivement recommand√©e, elle n'est pas obligatoire.
D'exp√©rience, tout le temps gagn√© en d√©veloppant en JS est perdu en cherchant des bugs qui auraient
√©t√© √©vit√©s en Typescript.<br/>
Le dossier `scripts` contient une requ√™te SQL pour cr√©er la table `users` permettant la gestion des utilisateurs.<br/>
Le dossier `api` contient les services "back" utilis√©s par l'application, qui sont ex√©cut√©s en tant que
fonctions Serverless sur Vercel.

### Serverless

Vercel repose sur les services Amazon Web Services (AWS) qui constitue le principal h√©bergeur mondial.
La prise en main d'AWS est trop complexe et trop longue pour un TP. Heureusement, Vercel s'occupe de tout.

Au cours du setup, vous avez d√©j√† pu cr√©er une base de donn√©es et un cache en trois clics,
sans avoir faire d'installation ou √† g√©rer des composants d'infrastructure.
De la m√™me fa√ßon, le code serveur n√©cessaire √† l'application sera ex√©cut√© dans des conteneurs NodeJs,
instanci√©s √† la demande, sans avoir √† g√©rer de serveur Web.

<p>&nbsp;</p>

## La gestion des utilisateurs

### La connexion

Le squelette d'application fourni contient d√©j√† un formulaire de connexion basique.

Le service `/api/login` permet de r√©cup√©rer un token de session qu'on stocke en session storage,
afin qu'il soit persist√© lors d'un refresh du site. <br/>
Il est pr√©sent [ici](api/login.js).<br/>
Avant de passer √† la suite, lire la note sur la [gestion du mot de passe](#mdp)

<a id="session"></a>
Contrairement √† ce que vous avez peut-√™tre d√©j√† rencontr√© sur d'autres framework, ici la session utilisateur n'est pas g√©r√©e comme par magie
via des cookies, JSESSIONID ou autre.<br/>
Nous allons utiliser le sch√©ma [Bearer Authorization](https://swagger.io/docs/specification/v3_0/authentication/bearer-authentication/) : 
ce sera √† vous de g√©rer la persistance, au niveau du navigateur, du token de session r√©cup√©r√© lors de la connexion ; et d'envoyer ce token
en header de chaque requ√™te, sous la forme `Authorization: Bearer <token>`, afin de pouvoir valider la connexion de l'utilisateur au niveau
des services API.

<p>&nbsp;</p>

D√©roul√© du service login : 

- On calcule le hash du mot de passe
- On fait un select en base pour chercher un couple username / password qui correspond
- Si on n'en trouve pas, on renvoie une erreur
- On met √† jour la date de derni√®re connexion
- On g√©n√®re un token al√©atoire afin d'authentifier l'utilisateur
- On stocke ce token en cache avec une dur√©e d'expiration de 3600s (1h)
- On stocke les infos de l'utilisateur en cache dans une Map index√©e par son identifiant (peut √™tre utile dans la suite du TP üòâ).
- Pour finir, on retourne le token en r√©ponse.
- üö® Ce token est √† enregistrer au niveau de l'application React et il devra √™tre envoy√© lors de chaque
  appel API comme preuve de la connexion de l'utilisateur, sous la forme d'un header : `Authorization: Bearer le_token_re√ßu`.
  Le fichier [lib/session.js](lib/session.js) contient une fonction `checkSession()` permettant aux services API de v√©rifier que l'utilisateur est bien connect√© et qu'il a le droit d'appeler ce service.


### ‚úèÔ∏è Let's get started

- Mettre en place un store : Redux Toolkit ou Zustand (par piti√©, pas de Redux sans Toolkit)
- Int√©grer `React Router` et d√©placer le formulaire de connexion sur une page d√©di√©e
- Ajouter la lib UX de votre choix ([comparatif 1](https://dev.to/fredy/top-5-reactjs-ui-components-libraries-for-2023-4673),
  [comparatif 2](https://www.wearedevelopers.com/magazine/best-free-react-ui-libraries#toc-5)) afin d'avoir du style ‚ú®
- Personnaliser le formulaire de connexion pour le rendre plus attrayant


### ‚úèÔ∏è Ajouter de nouveaux utilisateurs

- Cr√©er une nouvelle page et un nouveau composant avec un formulaire d'inscription contenant les champs :
  login, email et mot de passe.
- S'inspirer du service login.js pour cr√©er un service permettant d'enregistrer un nouvel utilisateur.<br/>
  Celui-ci devra :
    - Contr√¥ler que tous les champs sont bien renseign√©s
    - V√©rifier qu'il n'existe pas d√©j√† un utilisateur avec le m√™me username ou le m√™me email
    - Hasher le mot de passe
    - G√©n√©rer un external_id (pour communiquer avec d'autres services, il est toujours utile d'avoir une r√©f√©rence utilisateur externe).
      Pour √ßa, utiliser la m√™me fonction que pour le token de connexion : `crypto.randomUUID().toString()`
    - Enregistrer le tout en base
- Une fois le nouvel utilisateur enregistr√©, vous pouvez au choix : le rediriger vers la page de connexion
  ou le connecter automatiquement pour qu'il puisse acc√©der directement √† la messagerie.
- Bonus : mettre √©galement en place la d√©connexion

<p>&nbsp;</p>

## La messagerie

 - ‚úèÔ∏è Cr√©er 3 composants (au moins), pour g√©rer : 
   - La liste des utilisateurs et des salons (groupes de discussion) auxquels envoyer des messages
   - La liste des message correspondant au choix pr√©c√©dent
   - L'√©tat global de la messagerie


### ‚úèÔ∏è Liste des utilisateurs

Le service [users.js](api/users.js) permet de v√©rifier que l'utilisateur est bien connect√© et de r√©cup√©rer la liste des utilisateurs existants (avec seulement leurs donn√©es publiques).

 - Utiliser ce service pour r√©cup√©rer la liste des utilisateurs et l'enregistrer dans le store
 - Si vous obtenez une erreur 401 "UNAUTHORIZED", c'est que vous avez oubli√© de [mettre le token de session en header](#session).
 - Afficher la liste avec le nom de chaque utilisateur et sa date de derni√®re connexion 
(filtrer pour ne pas afficher dans la liste l'utilisateur connect√© üòÅ)
 - Lors de la s√©lection d'un utilisateur, modifier l'URL (par exemple `/messages/user/{user_id}`),
de sorte √† retomber sur la bonne discussion lors d'un F5 ou de l'acc√®s au site directement par l'URL de la conversation cibl√©.
(c'est une pratique courante pour g√©rer les clients qui mettent les pages en favoris du navigateur).
 - Stocker dans le store la conversation s√©lectionn√©e


### Envoi d'un message

Vercel offre 2 types de Functions : les [Serverless Functions](https://vercel.com/docs/functions/serverless-functions)
qui sont ex√©cut√©es dans un environnement NodeJs classique ; et les [Edge Functions](https://vercel.com/docs/functions/edge-functions)
qui tournent sur un environnement Javascript all√©g√© (pour de meilleurs performances).
Jusqu'√† pr√©sent, la version Edge suffisait ; mais pour la gestion des messages, on aura besoin de la version Serverless.

Un exemple de squelette est fourni [message.js](api/message.js) et sera √† compl√©ter.<br/>
Plusieurs diff√©rences sont √† noter :

 - La Serverless Function prend en param√®tre un objet `reponse` sur lequel il faut appeler les fonctions `send()` ou `json()` pour renvoyer une r√©ponse.
 - La r√©cup√©ration du payload change : `await request.body;` vs `await request.json()`

<p>&nbsp;</p>

#### Enregistrement des messages

Pour la d√©mo, j'ai choisi de stocker les messages en cache, pendant 24h, en utilisant la fonction
Redis [LPUSH](https://vercel.com/docs/storage/vercel-kv/kv-reference#lpush).<br/>
Chaque conversation est stock√©e avec une cl√© permettant d'identifier les 2 utilisateurs concern√©s
(‚ö†Ô∏è Si la conversion concerne les utilisateurs A et B, elle doit pouvoir √™tre retrouv√©e par chacun des 2).

Si vous pr√©f√©rez cr√©er une table pour stocker les conversations en base de donn√©es, libre √† vous.

‚úèÔ∏è Compl√©ter le service d'enregistrement de message en fonction.

<p>&nbsp;</p>

#### ‚úèÔ∏è Liste des messages

Lors de la s√©lection d'un utilisateur, afficher la liste des messages √©chang√©s avec lui.

 - Adopter un affichage type conversation avec les messages re√ßus align√©s √† gauche et ceux envoy√©s align√©s √† droite.
 - Afficher l'√©metteur et la date de chaque message.
 - Bonus : ajouter de l'auto-scroll pour toujours afficher les derniers messages.


## Notifications

Pour notifier l'utilisateur de la r√©ception d'un nouveau message et actualiser automatiquement la page,
on va utiliser le service [Pusher](https://pusher.com/)

‚úèÔ∏è Cr√©er un compte Pusher et se familiariser avec la documentation.

Apr√®s la connexion ou lors de l'affichage des messages, v√©rifier si les notifications push sont activ√©es
```javascript
window.Notification.requestPermission().then((permission) => {
    if (permission === 'granted') {
      // OK
    }
});
```
‚ö†Ô∏è Sur certains navigateurs, il faut activer les notifications manuellement.
Sur MacOS, il faut √©galement activer les notifications Chrome dans les param√®tres de l'OS.

Instancier Pusher :
```javascript
const beamsClient = new PusherClient({
    instanceId: 'XXX',
});
```

Instancier et configurer le client :
```javascript
const beamsTokenProvider = new TokenProvider({
    url: "/api/beams",
    headers: {
        Authorization: "Bearer " + TOKEN_SESSION, // Headers your auth endpoint needs
    },
});

beamsClient.start()
    .then(() => beamsClient.addDeviceInterest('global'))
    .then(() => beamsClient.setUserId(USER_EXTERNALID, beamsTokenProvider))
    .then(() => {
        beamsClient.getDeviceId().then(deviceId => console.log("Push id : " + deviceId));
    })
    .catch(console.error);
```
Les variables `TOKEN_SESSION` et `USER_EXTERNALID` sont √† remplacer en fonction de votre impl√©mentation.

On ajoute un `DeviceInterest 'global'` qui permet de spammer tous les utilisateurs d'un coup.

Le `TokenProvider` va venir appeler le service [beams.js](api/beams.js) pour r√©cup√©rer un JWT permettant d'identifier
l'utilisateur aupr√®s du service Pusher.

Le service `beams.js` est √† adapter et √† configurer pour utiliser votre instance Pusher.
```javascript
const beamsClient = new PushNotifications({
    instanceId: process.env.PUSHER_INSTANCE_ID,
    secretKey: process.env.PUSHER_SECRET_KEY,
});
```
Les variables d'environnement Pusher sont √† configurer sur votre poste et sur votre projet Vercel.
On utilise l'externalId de l'utilisateur pour l'identifier aupr√®s du service.

Dans le service [message.js](api/message.js), envoyer une notification Push √† l'utilisateur destinataire du message
```javascript
const publishResponse = await beamsClient.publishToUsers([targetUser.externalId], {
    web: {
        notification: {
            title: user.username,
            body: message.content,
            ico: "https://www.univ-brest.fr/themes/custom/ubo_parent/favicon.ico",
            deep_link: "" /* lien permettant d'ouvrir directement la conversation concern√©e */,
        },
        data: {
            /* additionnal data */
        }
    },
});
```

A ce stade, vous devriez recevoir les notifications Push avec 2 utilisateurs diff√©rents, connect√©s sur 2 navigateurs diff√©rents (ex : Chrome + Firefox).

‚ö†Ô∏è Les notifications Push ne fonctionneront pas avec Safari.


### Service worker

La r√©ception de notifications Push n√©cessite l'enregistrement d'un `service worker`.
Il s'agit d'un fichier javascript qui tourne dans le navigateur en t√¢che de fond, m√™me quand le site web n'est pas affich√©.<br/>
Celui inclus dans le projet, [service-worker.js](public/service-worker.js), va appeler
la fonction `client.postMessage()` pour venir notifier notre application React de la r√©ception d'une notification.<br/>

‚úèÔ∏è Mettre un composant √† l'√©coute du service worker :
```javascript
const sw = navigator.serviceWorker;
if (sw != null) {
    sw.onmessage = (event) => {
        console.log("Got event from sw : " + event.data);
    }
}
```
A la r√©ception de l'√©v√©nement, mettre √† jour automatiquement les messages affich√©s.

<p>&nbsp;</p>

## Salons de discussion

Discuter √† 2, c'est bien ; en groupe, c'est mieux !

- Mettre en place une table en base de donn√©es pour stocker la liste des salons 
(pas oblig√© de suivre le format `rooms` fourni dans le [scripts/db.sql](scripts/db.sql))
- De m√™me que pour les utilisateurs : r√©cup√©rer et afficher la liste des salons
- Permettre l'envoi d'un message sur un salon
- Afficher la liste des messages d'un salon
- G√©rer les notifications push √† l'ensemble des membres d'un groupe

<p>&nbsp;</p>

## Pour les meilleurs üëë

Internet ne serait pas ce qu'il est sans les GIF !<br/>
Et √ßa tombe bien, en plus d'une BDD et d'un cache, Vercel propose √©galement du stockage de fichier via les [Blobs](https://vercel.com/docs/storage/vercel-blob).

Votre derni√®re mission, si vous l'acceptez : ajouter la gestion des images aux conversations :

![demo](doc/demo.gif)


<p>&nbsp;</p>


## Toujours plus üöÄ

Sky is the limit !

- Afficher le nombre de messages non lu au niveau de la liste des utilisateurs et des salons
- Mettre en place des fils de discussion (liste de messages associ√©s √† un message)
- Ajouter des likes et/ou des emoji de r√©action sur les messages
- Permettre la cr√©ation dynamique de nouveaux groupes de discussion
- G√©rer des groupes priv√©s (visibles uniquement de certains utilisateurs)


<p>&nbsp;</p>



## Notes

<a id="mdp"></a>
### La gestion du mot de passe
M√™me s'il s'agit d'un TP, pour faire les choses bien, on ne stocke pas de mots de passe en clair en base de donn√©es.
La convention est d'utiliser une fonction de hashage qui permet de calculer une empreinte du mot de passe,
afin qu'il ne soit pas possible de retrouver le mot de passe initial √† partir de son empreinte.<br/>
A chaque connexion, on vient re-calculer le hash du mot de passe pour le comparer avec celui enregistr√© en base.

Par simplicit√©, on utilisera ici la fonction `SHA-256` qui est nativement support√©e dans l'environnement JS ;
mais celle-ci n'est plus consid√©r√©e comme s√©curis√©e et une alternative plus robuste tel que `bcrypt` serait normalement √† privil√©gier.

‚ö†Ô∏è Lors de la connexion, il peut √™tre tentant de calculer le hash du mot de passe au niveau du navigateur, avant de l'envoyer au service de connexion,
afin qu'il ne soit pas en clair dans la requ√™te.<br/>
Il s'agit d'une **tr√®s** mauvaise id√©e !
Un attaquant qui aurait r√©ussi √† r√©cup√©rer le contenu de la base de donn√©es pourrait alors se connecter √† la place de n'importe quel utilisateur
en envoyant directement le hash, sans avoir besoin de connaitre le vrai mot de passe.

2√®me bonne pratique, on ne hash jamais un mot de passe seul. La concat√©nation avec un al√©a unique
(dans le TP, il s'agit du username) permet de se pr√©munir des attaques de type [Rainbow table](https://fr.wikipedia.org/wiki/Rainbow_table).

Ainsi, dans l'exemple fourni dans [scripts/db.sql](scripts/db.sql), le login test / testubo se traduit
par le stockage en base de `gcrjEewWyAuYskG3dd6gFTqsC6/SKRsbTZ+g1XHDO10=`, que l'on peut v√©rifier avec la commande :
```bash
echo -n testtestubo | openssl sha256 -binary | base64
```

<p>&nbsp;</p>

### Chiffrement des messages

Le TP n'aborde pas la probl√©matique de confidentialit√© des messages.<br/>
Les plus curieux auront pu d√©couvrir (√©ventuellement au d√©tour d'analyses de dugs) qu'il est possible de lister toutes
les conversations depuis l'interface CLI d'Upstash :

![demo](doc/redis.png)

<p>&nbsp;</p>

#### Et dans la vraie vie, √ßa marche comment ?

Les applications de messagerie telles que WhatsApp utilisent du chiffrement de bout en bout, abr√©g√© E2EE (pour End to End Encryption).<br/>
Les algorithmes utilis√©s reposent principalement sur le chiffrement asym√©trique, qui permet de s'assurer que seul le destinataire sera capable de d√©chiffrer les messages envoy√©s.

Voici quelques ressources int√©ressantes :

- [Chiffrement et signature](https://medium.com/kobalt-si/chiffrement-et-signature-num%C3%A9rique-5798b1e1f8cf)
- [Protocol Signal](https://raw.githubusercontent.com/DanielArian/protocole-signal-explique/main/The%20Signal%20Protocol.pdf)


<p>&nbsp;</p>
